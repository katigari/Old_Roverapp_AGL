/* Copyright 2018 Pedro Cuadra - pjcuadra@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* WARNING: This file is automatically generated by raml2agl */
#include <service/ServiceRoverQmc5883L.h>
#include <roverapi/rover_qmc5883l.hpp>
#include <roverapi/rover_api.hpp>

using namespace rover;

static RoverQMC5883L sensor;
static RoverBase base;

ServiceRoverQmc5883L::ServiceRoverQmc5883L() {
  AFB_NOTICE("[ServiceRoverQmc5883L] Constructor ");
}

int ServiceRoverQmc5883L::init() {
  AFB_NOTICE("[ServiceRoverQmc5883L] Init ");
  base.initialize();

  sensor.initialize();
  sensor.calibrate();

  return 0;
}


/** Autogenrated doc for calibrate */
int ServiceRoverQmc5883L::calibrate() {
  AFB_NOTICE("[ServiceRoverQmc5883L] Calibrate");

  sensor.calibrate();

  return 0;
}

/** Autogenrated doc for get_address */
int ServiceRoverQmc5883L::get_address(int &out_address) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Get_address");

  out_address = sensor.getQMC5883LAddress();

  return 0;
}

/** Autogenrated doc for get_calibration_period */
int ServiceRoverQmc5883L::get_calibration_period(int &out_period) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Get_calibration_period");

  out_period = sensor.getQMC5883LCalibrationPeriod();

  return 0;
}

/** Autogenrated doc for get_declination_angle */
int ServiceRoverQmc5883L::get_declination_angle(double &out_angle) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Get_declination_angle");

  out_angle = static_cast<double>(sensor.getQMC5883LDeclinationAngle());

  return 0;
}

/** Autogenrated doc for read */
int ServiceRoverQmc5883L::read(double &out_bearing_value) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Read");

  out_bearing_value = static_cast<double>(sensor.read());

  return 0;
}

/** Autogenrated doc for set_address */
int ServiceRoverQmc5883L::set_address(const int in_address) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Set_address");

  sensor.setQMC5883LAddress(in_address);

  return 0;
}

/** Autogenrated doc for set_calibration_period */
int ServiceRoverQmc5883L::set_calibration_period(const int in_period) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Set_calibration_period");

  sensor.setQMC5883LCalibrationPeriod(in_period);

  return 0;
}

/** Autogenrated doc for set_declination_angle */
int ServiceRoverQmc5883L::set_declination_angle(const double in_angle) {
  AFB_NOTICE("[ServiceRoverQmc5883L] Set_declination_angle");

  sensor.setQMC5883LDeclinationAngle(static_cast<const float>(in_angle));

  return 0;
}
